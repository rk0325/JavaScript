# JavaScript

## DOM(Document Object Model)

HTMLを解釈し木構造で表現したもの

devツールで確認できる

JavaScriptやjQueryのコードは、レンダリングコスト(画面の表示速度)に問題が生じやすかったり、コードが肥大化してくるとどこで何をしているかわからなくなる→仮想DOMが作られた

↓

### **仮想DOM**

仮想DOMはJavaScriptもオブジェクトで作られた仮想的なDOM

実際のDOMとの差分を比較し変更箇所のみを実際のDOMに反映することで、DOMへの操作を最小限に抑えることが可能になる

ReactやVueなどのモダンJavaScriptのフレームワークやライブラリでは仮想DOMが用いられている→ページ遷移をJavaScriptによる画面の書き換えで表現しているが、レンダリングコストを最小限に抑えて快適なWebシステムを提供することが可能となっている

## パッケージマネージャー(npm / yarn)

- JavaScriptのnpm
- Rubyのgem
- PHPのcomposer

など

- 依存関係を意識しなくても勝手に解決してくれる
- チーム内でのパッケージの共有や、バージョン統一が容易
- 世界中で公開されているパッケージをコマンド1つで利用可能
- どこから読み込んだものか分かりやすくなった

### NPM

世界中の人がパッケージの公開場所として使用しているレジストリ

(一般的に大文字の場合はレジストリ、小文字の場合はパッケージマネージャーとしてのnpmを指すことが多い)

**自分のPCにパッケージをインストールする方法**

npmの場合

```ruby
npm install [パッケージ名]
```

yarnの場合

```ruby
yarn add [パッケージ名]
```

上記のコマンド実行時に、ローカルファイルのpackage.jsonが更新されパッケージの情報が追記される。それと同時にnpmでインストールした場合はpackage-lock.json、yarnでインストールした場合はyarn.lockファイルが生成(更新)される

lockファイルにはパッケージが内部で使用している別パッケージなどのバージョン情報や依存関係が記載されている

この2つのファイルを用いることで「どんなパッケージがどのバージョンでインストールされているのか」が分かるので、他の人の端末などでも全く同じ環境をすぐに作ることができる

package.jsonとpackage-lock.json(yarn.lock)の2ファイルからモジュールを展開(同じ環境を作成)するのも簡単！

npmの場合

```ruby
npm install
```

yarnの場合

```ruby
yarn add
```

上記のコマンドを実行すると、2つのファイルを参照してバージョンや依存関係が解決された状態で、node_modulesというフォルダが生成され、その中にパッケージの実体が展開される

実際にプログラムを実行するときにはこのnode_modulesの中を参照して便利なパッケージを動かすことができている

⚠️node_modulesフォルダ配下はサイズが膨大になるので、GitHubなどのソースコード管理ツール上にあげたり、コピペして移動はしないようにする

packageの2ファイルがあればどの環境でも同じnode_modulesを再現できるので、重たいファイルをわざわざやり取りする必要がない

## ECMAScript

JavaScriptはブラウザ上で動作する言語

ECMAScript

好き勝手に機能を追加しないようにするために、JavaScriptの標準仕様が定められている

1年に1回更新される

ES2015(ES6)で大きな機能追加が実施された

## モジュールバンドラー、トランスパイラ

**create-react-app**

Reactのテンプレートプロジェクトを作成してくれる

モジュールバンドラーやトランスパイラを意識しなくても開発をスタートできる

### モジュールバンドラー

「開発はファイルを分けて行い、本番用にビルドする時に1つのファイルにまとめよう」という思想を実現するために、jsファイルやcssファイルなどをまとめてくれる

パッケージマネージャーと同様、ファイルを1つにまとめる際に依存関係を解決してくれる

あらかじめ設定ファイルを記述しておき、ビルドを実行するとモジュールバンドラーがいい感じにファイルをまとめてバンドル後のファイルを生成してくれる、そのファイルを本番環境に反映することでプログラムを実行することができる

現在主流のモジュールバンドラーは**webpack**と呼ばれるもの

### トランスパイラ

モジュールバンドラー→複数のファイルを1つにまとめてくれるもの

トランスパイラ→JavaScriptの記法を色々なブラウザで実行できる形に変換してくれるもの

現在主流のトランスパイラ→**Babel**と呼ばれるもの

### モジュールバンドラーとトランスパイラのまとめ

共通点→「開発は効率よく、実行時は上手く変換」

これから主流になると言われているフロントエンドのビルドツールに**Vite(ヴィート)**がある

webpackを使った開発より圧倒的に高速

webpack→プロジェクトが肥大化するにつれてバンドルに時間がかかる

Vite→開発環境においてはソースコードをバンドルすることなく高速に実行できるようにしている

サーバーの立ち上げも高速

### SPA(Single Page Application)

SPAでは基本HTMLファイルは1つのみで、JavaScriptで画面を書き換えることで画面遷移などの動きを表現していく

### 従来のWebシステム

ページ遷移のたびにサーバー側にリクエストが送られサーバー側からHTMLファイルを返却するためページ遷移の際に一瞬画面が白くなる(チラつく)

### SPAのWebシステム

HTMLファイルのリクエストとは異なり、データの取得は非同期的に実行できる(裏でデータ取得が実行されるため、ユーザーは操作を続けられる)ためページ遷移時に画面のチラつきはなく、快適に閲覧が可能

**SPAではHTMLファイルは1つのみで、JavaScriptによるDOMの書き換えで画面遷移を実現するのが基本となる**

**メリット**

- ユーザー体験の向上
- コンポーネント分割が容易になることでの開発効率アップ

## const、letでの変数宣言

varでの変数宣言の問題点

上書き可能、再宣言可能

```jsx
var vali = "var変数";
console.log(vali); // var変数

// var変数は上書き可能
vali = "var変数を上書き";
console.log(vali); // var変数を上書き

// var変数は再宣言可能
var vali = "var変数を再宣言";
console.log(vali); // var変数を再宣言
```

上書き可能→一度定義した変数に別の値を代入することができること

無条件に上書きされてしまうと不便

再宣言可能→全く同じ変換名を複数箇所で変数定義できること

プログラムの実行順序によってどちらの変数が使用されるか読み解くのが難しいため基本できない方が望ましい

ES2015では新たな変数宣言の方法として**const**と**let**が追加された

### letでの変数宣言

再宣言不可能、上書き可能

→上書きしていくような変数はletを使用

### constでの変数宣言

再宣言も上書きも不可能＝**定数**

### constで定義した変数を変更できる例

オブジェクトや配列などのオブジェクト型はconstで定義していても中の値を変更できる

オブジェクト・配列の定義は基本的にconstを使用

### React開発で使用する変数宣言

constがほとんど

React開発の中で動的に変わるような値は**State**という別の概念で値を管理していく

Stateで管理せず処理の中で値を上書きしていくような変数のみletを使う流れが一般的

## テンプレート文字列

文字列の中で変数を展開するための新しい記法

`(バッククォート)で文字列を囲む

${　}で囲んだ中にはJavaScriptを書くことができる

```jsx
const name = "主田";
const age = 24;
const message = 私の名前は${name}です。年齢は${age}歳です。;
console.log(message); // 私の名前は主田です。年齢は24歳です。
```

## アロー関数

アロー関数はES2015で追加された新しい関数の記法

### 従来の関数

```jsx
function func1(value) {
  return value;
}

console.log(func1("func1です")); // func1です
```

従来はJavaScriptで関数を定義する場合、**function**という記述の後に関数名や引数、処理内容を記述していた

以下のように、宣言した関数を一度変数に格納してから実行することもできる

```jsx
const func1 = function (value) {
  return value;
};

console.log(func1("func1です")); // func1です
```

### アロー関数

**function**は使用せず関数を宣言

```jsx
const func2 = (value) => {
  return value;
};

console.log(func2("func2です")); // func2です
```

### アロー関数の書き方の注意点

省略記法1つ目→引数が1つの場合はカッコを省略できる

```jsx
const func2 = value => {
return value;
};

console.log(func2("func2です")); // func2です
```

2つ目→処理を単一行で返却する場合は波カッコとreturnを省略できる

```jsx
const func4 = (num1, num2) => num1 + num2;

console.log(func4(10, 20)); // 30
```

返却値が複数行に及ぶ場合には、**( )で囲む**ことで単一行のようにまとめて返却することができるため以下のような書き方ができる

```jsx
const func5 = (val1, val2) => (
  {
     name: val1,
     age: val2,
  }
)

console.log(func5("主田", 24)); // {name: "主田", age: 24}
```

**Prettier　コード整形ツール**

コード整形のルールを統一してくれるもの

## 分割代入

分割代入は、オブジェクトや配列から値を抽出するための方法

分割代入を使用しない場合

```jsx
const myProfile = {
  name: "主田",
  age: 24,
};

const message = `私の名前は${myProfile.name}です。年齢は${myProfile.age}歳です。`;
console.log(message); // 私の名前は主田です。年齢は24歳です。
```

分割代入を用いると…

```jsx
const myProfile = {
  name: "主田",
  age: 24,
};

// オブジェクトの分割代入
const { name, age } = myProfile;
const message = `私の名前は${name}です。年齢は${age}歳です。`;
console.log(message); // 私の名前は主田です。年齢は24歳です。
```

{ }を変数宣言部に使用することでオブジェクト内から一致するプロパティを取り出すことができる

存在しないプロパティ名は指定できない

名称さえ合っていれば、一部のみ取り出したり、順番が違ってもOK
